--- 
toc-title: Conteúdo
---

# Modelos de Classificação 

```{r, echo=F}
data_cancer = readr::read_csv('./data/data.csv') |>
  dplyr::mutate(diagnosis = as.factor(diagnosis)) |>
  dplyr::select(id, diagnosis , dplyr::contains('_mean')) |>
  dplyr::select(-perimeter_mean, -radius_mean) |>
  janitor::clean_names()

set.seed(607) #Fixando semente para reprodução dos resultados 
data_cancer_split = rsample::initial_split(data_cancer, prop = 0.80, strata = diagnosis)
data_cancer_train = rsample::training(data_cancer_split)
data_cancer_test = rsample::testing(data_cancer_split)

```

A classificação correta de tumores benignos e malignos desempenha um papel crucial no diagnóstico precoce e tratamento eficaz do câncer. Nesse contexto, os modelos de classificação surgem como ferramentas promissoras na área médica, permitindo a análise automatizada de características clínicas, genéticas e radiológicas para diferenciar entre tumores benignos e malignos. Esses modelos utilizam algoritmos de aprendizado de máquina para extrair padrões relevantes dos dados e fazer previsões precisas. Ao fornecer informações valiosas para médicos e especialistas, os modelos de classificação podem auxiliar na identificação de pacientes em risco, direcionar tratamentos personalizados e melhorar os resultados clínicos. Neste trabalho, exploraremos diferentes abordagens de modelos de classificação e discutiremos sua aplicação na discriminação entre tumores benignos e malignos, com o objetivo de aprimorar a detecção precoce e o tratamento eficiente do câncer.

A documentação dos dados cita que tal classificação indica o proseguindo ou não do paciente para exames mais invasivos, tal sequencia é ilustrada pelo seguinte diagrama:

![](figs/diag_fp_fn.drawio.png){height=500px, fig-align="center"}

Porém, assim como todos modelos estatísticos, os modelos de classificação apresentam erros, tais erros de classificação são denominados **Falso Positivo** e **Falso Negativo**, onde no caso dos dados trabalhados:

* Falso Positivo: Falsa classificação de um paciente sem tumor maligno como portador de tal tumor

* Falso Negativo: Falsa classificação de um paciente com tumor maligno como não sendo portador de tal tumor

Tal definição é importante para a definição de limites e custos de erros.

O custo de erro associado ao erro **Falso Negativo** é maior que o **Falso Positivo** pois indica que um paciente com tumor maligno não deverá avancar em seu tratamento, podendo levar o mesmo a um estágio mortal da doença. Já a classificação Falso Positivo indica que o paciente sem tumor maligno avançe na diagnóstico da doença, onde serão utilizados metodos mais invasivos para isso

Portanto, o diagrama real é dada por:

![](figs/diag_ver.drawio.png){height=500px, fig-align="center"}



```{r, message = F, warning=F}
library(tidymodels)
library(tidyverse)

variables_to_remove = data_cancer |>
  dplyr::select(contains("_mean")) |>
  names()

cancer_recipe = recipes::recipe(diagnosis ~ .,
                                data = data_cancer_train) |>
      recipes::update_role(id, new_role = "id") |>
      step_normalize(all_predictors()) |>
      step_mutate(anomaly_features = (area_mean + concave_points_mean + concavity_mean + texture_mean)/4,
                  structure_feature = (compactness_mean + fractal_dimension_mean + smoothness_mean + symmetry_mean)/4) |>
  update_role(all_of(variables_to_remove), new_role = "ignore")

wf = workflows::workflow() |> 
  workflows::add_recipe(cancer_recipe)


```


## Análise de Discriminante

O objetivo da análise discriminante é encontrar uma função discriminante que maximize a separação entre os grupos, levando em consideração a estrutura das variáveis preditoras.

Dado o contexto do problema estudado, a função discriminante estimada foi aquela que maximizou a separação entre os grupos de pessoas  com tumor benigno e maligno.

### Análise via Discriminante Linear

```{r, warning=F, message=F}
library(discrim)

data_cancer_train = cancer_recipe |> prep() |> bake(new_data = NULL) 

cross_folds = rsample::vfold_cv(data_cancer_train, strata = diagnosis)
```


```{r}
lda_spec = discrim_linear() |>
  set_mode('classification') |>
  set_engine('MASS')

lda_fit = wf |>
  workflows:: add_model(lda_spec) |>
parsnip::fit(data = data_cancer_train)
  
```

```{r}
library(tidyverse)
library(tidymodels)

lda_metrics = lda_fit |> 
  tune::fit_resamples(cross_folds,
    metrics = yardstick::metric_set(accuracy, roc_auc, sens, j_index, specificity),
    control = tune::control_resamples(save_pred = TRUE)) |>
  workflowsets::collect_metrics() |>
  mutate(lower_bound = mean - 1.96*std_err, upper_bound = mean + 1.96*std_err)
```



### Análise via Discriminante Quadrático

```{r}
cov_diagnosis = list('B','M') |>
  map(~data_cancer_train |>
        filter(diagnosis == .) |>
        dplyr::select(-'id', -'diagnosis') |>
        cov())

cov_diagnosis[[1]] - cov_diagnosis[[2]]
```


```{r}
qda_spec = discrim_quad() |>
  set_mode('classification') |>
  set_engine('MASS')

qda_fit = wf |>
  add_model(qda_spec) |>
  fit(data = data_cancer_train)
```

```{r}
qda_fitted_resamples = qda_fit |> 
  fit_resamples(cross_folds,
    metrics = metric_set(accuracy, roc_auc, sens, j_index, specificity),
    control = control_resamples(save_pred = TRUE))

qda_metrics =  qda_fitted_resamples |>
  collect_metrics() |>
  mutate(lower_bound = mean - 1.96*std_err, upper_bound = mean + 1.96*std_err)
```

```{r}
augment(qda_fitted_resamples) |>
  roc_curve(diagnosis, .pred_B) |>
  autoplot()
```



## Escolha do Melhor Discriminante

Observando as estimativas obtidas via, viu-se que ambos os modelos apresentaram desempenho semelhantes. Assim utilizou-se como critério principal aquele que obteve o melhor desempenho na métrica **sensibilidade** dado que o contexto do problema trabalho indica um maior custo de erro para **Falso Negativo**

Para melhor visualização, construi-se a seguinte tabela comparando o valor da sensibilidade de ambos os modelos:

```{r}
bind_rows(lda_metrics, qda_metrics) |>
  filter(.metric == 'sens') |>
  dplyr::select(-.config, -.estimator) |>
  mutate(model = c('LDA', 'QDA')) |>
  relocate(model) |>
  kableExtra::kbl() %>%
  kableExtra::kable_material(c("striped", "hover"))
  
```

Novamente, ambos os modelos se mostraram extramamentes semelhantes, porém notou-se um ligeiro melhor desempenho por parte do modelo Linear. Assim, escolheu-se ele para a etapa de final de escolha de melhor modelo

# Modelos de Regressão e Apredendizado de Máquina

## Regressão Logística

```{r}
logistic_spec = parsnip::logistic_reg() |>
  parsnip::set_engine("glm", family = stats::binomial(link='logit')) |>
  parsnip::set_mode("classification")
```

```{r}
lr_fit = wf |>
  workflows::add_model(logistic_spec) |>
  parsnip::fit(data_cancer_train) 


lr_fitted_resamples = lr_fit |>
  fit_resamples(cross_folds,
    metrics = metric_set(accuracy, roc_auc, sens, j_index, specificity),
    control = control_resamples(save_pred = TRUE))

lr_metrics = lr_fitted_resamples |> 
  collect_metrics() |>
  mutate(lower_bound = mean - 1.96*std_err, upper_bound = mean + 1.96*std_err)

```




## Randon Forest

```{r, message=F, warning=F}
library(randomForest)

rand_forest_spec = rand_forest(
  mtry = tune(),
  trees = 2000,
  min_n = tune()
) %>%
  set_mode("classification") %>%
  set_engine("randomForest")
```

```{r}
rand_forest_fit = wf |>
  workflows::add_model(rand_forest_spec) 

doParallel::registerDoParallel()

rand_forest_tune = rand_forest_fit |>
  tune_grid(
    resamples = cross_folds,
    metrics = metric_set(accuracy, roc_auc, sens, j_index, specificity),
    grid = 20)

rand_forest_tune |>
  collect_metrics() %>%
  filter(.metric == 'sens') %>%
  dplyr::select(mean, min_n, mtry) %>%
  pivot_longer(min_n:mtry,
    values_to = "value",
    names_to = "parameter"
  ) %>%
  ggplot(aes(value, mean, color = parameter)) +
  geom_point(show.legend = FALSE) +
  facet_wrap(~parameter, scales = "free_x") +
  labs(x = NULL, y = "sens")


rand_forest_tune |>
  collect_metrics() %>%
  filter(.metric == 'roc_auc') %>%
  dplyr::select(mean, min_n, mtry) %>%
  pivot_longer(min_n:mtry,
    values_to = "value",
    names_to = "parameter"
  ) %>%
  ggplot(aes(value, mean, color = parameter)) +
  geom_point(show.legend = FALSE) +
  facet_wrap(~parameter, scales = "free_x") +
  labs(x = NULL, y = "AUC")

```

```{r}
doParallel::registerDoParallel()
 grid_table = crossing(min_n = seq(10,11, by=.1),
          mtry = c(0,1, by = 0.1))

rand_forest_tune = rand_forest_fit |>
  tune_grid(
    resamples = cross_folds,
    metrics = metric_set(accuracy, roc_auc, sens, j_index, specificity),
    grid = grid_table)
```

```{r}
rand_forest_tune |> tune::select_best()
```
Após a otimização dos parametros

```{r}
rand_forest_spec = rand_forest(
  mtry = 0.1,
  trees = 2000,
  min_n = 10.3
) %>%
  set_mode("classification") %>%
  set_engine("randomForest")

rand_forest_fit = wf |>
  workflows::add_model(rand_forest_spec) 

rand_forest_fitted_resamples = rand_forest_fit |>
  fit_resamples(
    resamples = cross_folds,
    metrics = metric_set(accuracy, roc_auc, sens, j_index, specificity)
    )

```
```{r}
rand_forest_fitted_resamples = rand_forest_fitted_resamples |> 
  collect_metrics() 

rand_forest_fitted_resamples |>
    mutate(lower_bound = mean - 1.96*std_err, upper_bound = mean + 1.96*std_err) |>
    kableExtra::kbl() %>%
    kableExtra::kable_material(c("striped", "hover"))
```


## Escolha do melhor modelo

Nesse tópico trabalhou-se com os 3 modelos construidos: **Discriminante Linear**, **Regressão Logística** e **Random Forest Otimizado**

Para a escolha do melhor modelo, utilizou-se principalmente as métricas **Curva ROC, Sensibilidade e J-Index**


Os modelos possuem as seguintes metricas(para robuste dos valores, foi utilizado novamente metodo de validação cruzada)

```{r}
lda_metrics |>
  mutate(lower_bound = mean - 1.96*std_err, upper_bound = mean + 1.96*std_err) |>
  kableExtra::kbl() %>%
  kableExtra::kable_material(c("striped", "hover"))
```

```{r}
lr_metrics|>
  mutate(lower_bound = mean - 1.96*std_err, upper_bound = mean + 1.96*std_err) |>
  kableExtra::kbl() %>%
  kableExtra::kable_material(c("striped", "hover"))
```


```{r}
rand_forest_fitted_resamples|>
  mutate(lower_bound = mean - 1.96*std_err, upper_bound = mean + 1.96*std_err) |>
  kableExtra::kbl() %>%
  kableExtra::kable_material(c("striped", "hover"))
```



